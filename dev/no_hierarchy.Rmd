---
title: "Analysis Summary no_hierarchy"
author: "Jian"
date: "26/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r library, message = FALSE}
# Load libraries
library(tidyverse)
library(ggplot2)
library(plotly)
library(future)
library(furrr)
library(tidybulk)
library(cluster)
library(proxy)
library(factoextra)
library(stringr)
```

# 1 Load data

```{r data, message=F, warning=FALSE}
# Load data
# tt_simple <- readRDS("intermediate_data/tt_simple.rds")

```

# 2 Functions

```{r functions, message=F}
mean_contrast0 <- function(.data){
  
  prefix <- "cell_type"
  
  # find all cell types
  cell_types <- .data %>% 
    distinct(cell_type) %>% 
    pull() %>% 
    as.vector()
  
  # format cell_types with prefix
  cell_types <- paste0(prefix, cell_types)
  
  # initialise a vector called contrasts
  contrasts <- 1: length(cell_types)
  
  # create all contrasts and store them in contrasts
  for(i in 1:length(cell_types) ){
    background = paste(cell_types[-i], collapse = "+")
    divisor = length(cell_types[-i])
    contrasts[i] <- sprintf("%s-(%s)/%s", cell_types[i], background, divisor)
  }
  
  return(contrasts)
}

get_contrasts_from_df0 = function(.data){
  
  .data %>% 
    distinct(cell_type) %>% 
    mutate(cell_type = paste0("cell_type",cell_type)) %>% 
    
    # Permute
    mutate(cell_type2 = cell_type) %>% 
    expand(cell_type, cell_type2) %>% 
    filter(cell_type != cell_type2) %>% 
    
    # Create contrasts
    mutate(contrast = sprintf("%s - %s", cell_type, cell_type2)) %>%
    pull(contrast)
  
}

## 2.2 marker ranking & selection

select_markers_for_each_contrast = function(.markers, .sig_size){
  .markers %>%
    
    # Group by contrast. Comparisons both ways.
    pivot_longer(
      cols = contains("___"),
      names_to = c("stats", "contrast"), 
      values_to = ".value", 
      names_sep="___"
    ) %>% 
    
    # Markers selection within each pair of contrast
    nest(stat_df = -contrast) %>%
    
    # Reshape inside each contrast
    mutate(stat_df = map(stat_df, ~.x %>% pivot_wider(names_from = stats, values_from = .value))) %>%
    
    # Rank
    mutate(stat_df = map(stat_df, ~.x %>%
                           filter(FDR < 0.05 & logFC > 2) %>%
                           filter(logCPM > mean(logCPM)) %>%
                           arrange(logFC %>% desc()) %>%
                           slice(1: .sig_size)
                         
    )) %>%
    
    unnest(stat_df)
}

## 2.3 marker collection for each contrast

# mean contrast method
contrast_MC0 <- function(.tt){
  .tt %>%
    
    # Differential transcription
    mutate(markers = map(
      data,
      ~ test_differential_abundance(.x,
                                    ~ 0 + cell_type, 
                                    .contrasts = mean_contrast0(.x),
                                    action="only")  ))
}

# pairwise contrast method
contrast_PW0 <- function(.tt){
  .tt %>%
    
    # Differential transcription
    mutate(markers = map(
      data,
      ~ test_differential_abundance(.x,
                                    ~ 0 + cell_type, 
                                    .contrasts = get_contrasts_from_df0(.x),
                                    action="only")  ))
}

# marker selection & processing
sig_select0 <- function(.contrast, .sig_size) {
  .contrast %>% 
    
    # Select markers from each contrast by rank of stats
    mutate(markers = map(markers, ~ select_markers_for_each_contrast(.x, .sig_size))) %>%
    
    # Add original data info to the markers selected
    mutate(markers = map2(markers, data, ~ left_join(.x, .y))) %>%
    select(level_0, markers) %>%
    unnest(markers) %>%
    
    # make contrasts pretty
    mutate(contrast_pretty = str_replace(contrast, "cell_type", "") %>% str_replace("cell_type", ""))
}

## 2.4.1 calculate the area of confidence ellipses and the sum of their areas

## 5.1 calculate the area of confidence ellipses and the sum of their areas
ellipse0 <- function(.rdim, .method) {
  .rdim %>% 
    
    # remove non-numerical data to form a numerical data frame
    select(cell_type, 
           contains(str_sub(.method, end=-2L))) %>% 
    
    # normalize principle component values
    mutate(across(contains(str_sub(.method, end=-2L)), scale)) %>% 
    
    # nest by cell_type so as to calculate ellipse area for each cell type
    nest(dims = - cell_type) %>% 
    
    # obtain covariance matrix for each cell type
    mutate(cov = map(dims, ~ cov(.x))) %>% 
    
    # calculate the eigenvalues for the covariance matrix of each cell type
    mutate(eigval = map(cov, ~ eigen(.x)$values)) %>% 
    
    # transformation
    mutate(area = map(eigval, ~ sqrt(.x * qchisq(0.95, 2)))) %>%
    
    # below is the actual area for each ellipse
    mutate(area = map_dbl(area, ~ prod(.x)*pi)) %>% 
    
    # collect size of each cluster as factors for weights
    mutate(cluster_size = map_int(dims, ~ nrow(.x))) %>%
    
    # weight each area by the inverse of its cluster size
    mutate(weighted_area = map2_dbl(area, cluster_size, ~ .x / .y))
}

## 5.2 Ellipse area calculation 
ellip_func0 <- function(.markers, .method){
  .markers %>% 
    
    # nest by ancestor cell types
    nest(rdim = - level_0) %>%
    
    # reduce dimension
    mutate(rdim = map(rdim, ~ .x %>%
                        distinct(sample, symbol, count_scaled, cell_type))) %>%
    mutate(rdim = map(rdim, ~ .x %>%
                        reduce_dimensions(sample, symbol, count_scaled,
                                          method = .method,
                                          action = "add",
                                          transform = log1p,
                                          # check_duplicates is for Rtsne method
                                          check_duplicates = FALSE) %>% 
                        
                        # save symbols for calculating real_size while reducing replicated rows resulted from symbol
                        nest(data_symbol = c(symbol, count_scaled))
    )) %>% 
    
    mutate(real_size = map_int(rdim, ~ .x$data_symbol %>% 
                                 map_int(~ n_distinct(.x$symbol)) %>% 
                                 unlist() %>% 
                                 unique() )) %>% 
    
    mutate(area_df = map(rdim, ~ ellipse0(.x, .method) ))
  
}

## 5.3 Scale serialised ellip_func() output (a tibble called ellip_tb) for plotting
ellip_scale0 <- function(.ellip_tb) {
  .ellip_tb %>% 
    unnest(ellip) %>%
    unnest(area_df) %>%
    
    # nest by ancestor cell type to rescale area for all sig_sizes
    nest(cell_data = - level_0) %>%
    mutate(cell_data = map(cell_data, ~ .x %>% 
                             mutate(rescaled_area = area %>% 
                                      scale(center = F))
    )) %>%
    
    # nest by ancestor cell type to summarise areas for each real_size/sig_size
    mutate(plot_data = map(cell_data, ~ .x %>%
                             # sum all areas for each real_size for an ancestor node
                             group_by(real_size) %>%
                             summarise(sig_size,
                                       stded_sum=sum(area, na.rm = T),
                                       wted_sum = sum(weighted_area, na.rm = T),
                                       rescaled_sum= sum(rescaled_area, na.rm = T)) %>%
                             # remove duplicate rows
                             distinct(real_size, sig_size, stded_sum, wted_sum, rescaled_sum) %>% 
                             pivot_longer(ends_with("sum"), names_to='area_type', values_to="area_value")
    ))
}

## 2.5 Silhouette function
sil_func0 <- function(.markers, .method){
  .markers %>% 
    nest(rdim = - level_0) %>% 
    mutate(rdim = map(rdim, ~ .x %>% 
                        distinct(sample, symbol, count_scaled, cell_type))) %>% 
    mutate(rdim = map(rdim, ~ .x %>%
                        reduce_dimensions(sample, symbol, count_scaled,
                                          method = .method,
                                          action = "add",
                                          transform = log1p,
                                          # check_duplicates is for Rtsne method
                                          check_duplicates = FALSE) %>% 
                        
                        # save symbols for calculating real_size while reducing replicated rows resulted from symbol
                        nest(data_symbol = c(symbol, count_scaled))
    )) %>%
    
    # calculate the dissimilarity matrix with PC values
    mutate(distance = map(rdim, ~ .x %>%
                            select(contains(str_sub(.method, end = -2L))) %>%
                            factoextra::get_dist(method = "euclidean")
    )) %>%
    
    # calculate silhouette score
    mutate(sil = map2(rdim, distance, 
                      ~ silhouette(as.numeric(as.factor(`$`(.x, cell_type))), .y)
    )) %>% 
    mutate(sil = map(sil, ~ .x %>% summary())) %>%
    mutate(sil = map(sil, ~ .x %>% `$`(avg.width) ))%>% 
    mutate(sil = unlist(sil)) %>% 
    
    # obtain the actual number of signature genes
    mutate(real_size = map_int(rdim, ~ .x$data_symbol %>% 
                                 map_int(~ n_distinct(.x$symbol)) %>% 
                                 unlist() %>% 
                                 unique() ))
  
}
```


# 3 No hierarchy + mean contrast Analysis

## 3.1 Generate contrast with mean contrast method

```{r preprocess, message=F, results = FALSE, warning = FALSE}
# # 1 Setup data frame & preprocessing
# 
# tt_simple <- counts %>%
#   
#   mutate(level_0 = "cell") %>% 
#   
#   tidybulk(sample, symbol, count) %>%
#   
#   # filter for the cell types of interest for gene marker selection
#   filter(is.na(cell_type)==F) %>%
#   
#   # Group by ancestor
#   nest(data = - level_0) %>%
#   
#   # Eliminate genes that are present in some but all cell types
#   # (can be still present in a subset of samples from each cell-type)
#   mutate(data = map(
#     data,
#     ~ .x %>%
#       nest(data = -c(symbol, cell_type)) %>%
#       add_count(symbol) %>%
#       filter(n == max(n)) %>%
#       unnest(data)
#   )) %>%
#   
#   # Imputation of missing data within each level_5
#   mutate(data = map(data, ~ .x %>% impute_missing_abundance(~ cell_type))) %>%
#   
#   # scale count for further analysis
#   mutate(data=map(data, ~ .x %>%
#                     identify_abundant(factor_of_interest = cell_type) %>%
#                     scale_abundance()
#   ))

# contrast_NH_MC <- tt_simple %>% contrast_MC0()
```

```{r generate_contrast, message=FALSE, warning=FALSE}

contrast_NH_MC <- readRDS("intermediate_data/contrast_NH.rds")

```


## 3.2 Ellipse Area Analysis

```{r ellipse, results = FALSE, warning = FALSE, message=F}
sig_size <- 20

# create a tibble that stores the confidence ellipse area output for each signature size
ellip_tb0 <-
  tibble(sig_size = 1:sig_size) %>%
  # slice(1) %>%
  mutate(ellip = map(sig_size, ~ sig_select0(contrast_NH_MC, .x))) %>%
  mutate(ellip = map(ellip, ~ ellip_func0(.x, "PCA")))

# rescale areas and plot total areas vs the total number of markers selected from cell types in a level
ellip_data0 <- ellip_tb0 %>% ellip_scale0()
```

### 3.2.1 Signature size selection & PCA plot for all cell types

Signature size selection plot:

```{r sig_size_elli, warning = FALSE, message=F}
cell_elli0 <- ellip_data0 %>%
  pluck("plot_data", 1) %>%
  ggplot(aes(real_size, area_value, colour=area_type)) +
  geom_line() +
  geom_point() +
  # scale_x_continuous(sec.axis = sec_axis(as.factor())) +
  # facet_grid(rows = vars(area_type), scales = "free_y")
  facet_wrap(~ area_type, scales = "free_y")

cell_elli0
```

The elbow point indicates optimal sig_size is $8$. PCA at sig_size = $8$: 

```{r PCA0_cell_elli, message=F, warning = FALSE}
sig_size <- 8

PCA0_cell_elli <- ellip_tb0 %>% 
  pluck("ellip", 8) %>% 
  pluck("rdim", 1) %>% 
  ggplot(aes(x = PC1, y = PC2, colour = cell_type, label = sample)) + 
  geom_point() +
  stat_ellipse(type = 't')+
  theme_bw()

PCA0_cell_elli
```

## 3.3 Silhouette Analysis

```{r silhouette, message=F, results = FALSE, warning = FALSE}
sig_size <- 60

sil_tb0 <-
  tibble(sig_size = 1:sig_size) %>%
  # slice(1) %>%
  mutate(sil_df = map(sig_size, ~ sig_select0(contrast_NH_MC, .x))) %>%
  mutate(sil_df = map(sil_df, ~ sil_func0(.x, "PCA")))

sil_data0 <- sil_tb0 %>%
  unnest(sil_df) %>%
  nest(plot_data = - level_0)
```

### 3.3.1 Signature size selection & PCA plot for all cell types

Signature size selection plot:

```{r cell_sil0, warning = F, message=F}
cell_sil0 <- sil_data0 %>%
  pluck("plot_data", 1) %>%
  ggplot(aes(real_size, sil)) +
  geom_line() +
  geom_point()

cell_sil0
```

```{r max_sig2, warning=F, message=F}
# find out which sig_size gives the maximum silhouette score
sil_data0 %>% 
  pluck("plot_data", 1) %>%
  pull(sil) %>% 
  which.max()
```

```{r, warning=F, message=F}
# find out what the maximum silhouette score is
sil_data0 %>% 
  pluck("plot_data", 1) %>%
  pull(sil) %>% 
  max()
```

The peak is reached when sig_size = $46$. PCA at sig_size = $46$:

```{r PCA0_cell_sil, message=F, warning = FALSE}
sig_size <- 46

PCA0_cell_sil <- sil_tb0 %>% 
  pluck("sil_df", 46) %>% 
  pluck("rdim", 1) %>% 
  ggplot(aes(x = PC1, y = PC2, colour = cell_type, label = sample)) + 
  geom_point() +
  stat_ellipse(type = 't')+
  theme_bw()

PCA0_cell_sil
```

# 4 No hierarchy + pairwise comparison Analysis

## 4.1 Generate contrast with mean contrast method

```{r generate_contrast_pw, message=F, results = FALSE, warning = FALSE}
# # 1 Setup data frame & preprocessing
# 
# contrast_NH_pairwise <- tt_simple %>% 
#   contrast_PW0()
# 
# saveRDS(contrast_NH_pairwise, "contrast_NH_pairwise.rds")

```

```{r pairwise_contrast, message=FALSE, warning=FALSE}

contrast_NH_PW <- readRDS("intermediate_data/contrast_NH_pairwise.rds")

```

## 4.2 Ellipse Area Analysis

```{r ellipse_4.2, results = FALSE, warning = FALSE, message=F}
sig_size <- 20

# create a tibble that stores the confidence ellipse area output for each signature size
ellip_tb0 <-
  tibble(sig_size = 1:sig_size) %>%
  # slice(1) %>%
  mutate(ellip = map(sig_size, ~ sig_select0(contrast_NH_PW, .x))) %>%
  mutate(ellip = map(ellip, ~ ellip_func0(.x, "PCA")))

# rescale areas and plot total areas vs the total number of markers selected from cell types in a level
ellip_data0 <- ellip_tb0 %>% ellip_scale0()
```

### 4.2.1 Signature size selection & PCA plot for all cell types

Signature size selection plot:

```{r sig_size_elli_4.2.1, warning = FALSE, message=F}
cell_elli0 <- ellip_data0 %>%
  pluck("plot_data", 1) %>%
  ggplot(aes(real_size, area_value, colour=area_type)) +
  geom_line() +
  geom_point() +
  # scale_x_continuous(sec.axis = sec_axis(as.factor())) +
  # facet_grid(rows = vars(area_type), scales = "free_y")
  facet_wrap(~ area_type, scales = "free_y")

cell_elli0
```

The elbow point indicates optimal sig_size is $3$. PCA at sig_size = $3$: 

```{r PCA0_cell_elli_4.2.1, message=F, warning = FALSE}
sig_size <- 3

PCA0_cell_elli <- ellip_tb0 %>% 
  pluck("ellip", 3) %>% 
  pluck("rdim", 1) %>% 
  ggplot(aes(x = PC1, y = PC2, colour = cell_type, label = sample)) + 
  geom_point() +
  stat_ellipse(type = 't')+
  theme_bw()

PCA0_cell_elli
```

## 4.3 Silhouette Analysis

```{r silhouette_4.3, message=F, results = FALSE, warning = FALSE}
sig_size <- 30

sil_tb0 <-
  tibble(sig_size = 1:sig_size) %>%
  # slice(1) %>%
  mutate(sil_df = map(sig_size, ~ sig_select0(contrast_NH_PW, .x))) %>%
  mutate(sil_df = map(sil_df, ~.x %>% sil_func0("PCA")))

sil_data0 <- sil_tb0 %>%
  unnest(sil_df) %>%
  nest(plot_data = - level_0)
```


### 4.3.1 Signature size selection & PCA plot for all cell types

Signature size selection plot:

```{r cell_sil0_4.3.1, warning = F, message=F}
cell_sil0 <- sil_data0 %>%
  pluck("plot_data", 1) %>% 
  ggplot(aes(real_size, sil)) +
  geom_line() +
  geom_point()

cell_sil0
```

```{r max_sig3, warning=F, message=F}
sil_data0 %>% 
  pluck("plot_data", 1) %>%
  pull(sil) %>% 
  which.max()
```

```{r, warning=F, message=F}
# find out what the maximum silhouette score is
sil_data0 %>% 
  pluck("plot_data", 1) %>%
  pull(sil) %>% 
  max()
```

The peak is reached when sig_size = $3$. PCA at sig_size = $3$:

```{r PCA0_cell_sil_4.3.1, message=F, warning = FALSE}
sig_size <- 3

PCA0_cell_sil <- sil_tb0 %>% 
  pluck("sil_df", 3) %>% 
  pluck("rdim", 1) %>% 
  ggplot(aes(x = PC1, y = PC2, colour = cell_type, label = sample)) + 
  geom_point() +
  stat_ellipse(type = 't')+
  theme_bw()

PCA0_cell_sil
```

